<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>cortex.polyutils.surface &#8212; pycortex 1.2.10 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=12dfc556" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-binder.css?v=f4aeca0c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-dataframe.css?v=2082cf3c" />
    <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery-rendered-html.css?v=1277b6f3" />
    <script src="../../../_static/documentation_options.js?v=12f20e84"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for cortex.polyutils.surface</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>

<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numexpr</span> <span class="k">as</span> <span class="nn">ne</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">distance</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">sparse</span>
<span class="kn">import</span> <span class="nn">scipy.sparse.linalg</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">exact_geodesic</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">subsurface</span>
<span class="kn">from</span> <span class="nn">.misc</span> <span class="kn">import</span> <span class="n">_memo</span>


<div class="viewcode-block" id="Surface">
<a class="viewcode-back" href="../../../generated/cortex.polyutils.Surface.html#cortex.polyutils.Surface">[docs]</a>
<span class="k">class</span> <span class="nc">Surface</span><span class="p">(</span><span class="n">exact_geodesic</span><span class="o">.</span><span class="n">ExactGeodesicMixin</span><span class="p">,</span> <span class="n">subsurface</span><span class="o">.</span><span class="n">SubsurfaceMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents a single cortical hemisphere surface. Can be the white matter surface,</span>
<span class="sd">    pial surface, fiducial (mid-cortical) surface, inflated surface, flattened surface,</span>
<span class="sd">    etc.</span>

<span class="sd">    Implements some useful functions for dealing with functions across surfaces.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    pts : 2D ndarray, shape (total_verts, 3)</span>
<span class="sd">        Location of each vertex in space (mm). Order is x, y, z.</span>
<span class="sd">    polys : 2D ndarray, shape (total_polys, 3)</span>
<span class="sd">        Indices of the vertices in each triangle in the surface.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Surface.__init__">
<a class="viewcode-back" href="../../../generated/Surface/cortex.polyutils.Surface.__init__.html#cortex.polyutils.Surface.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">polys</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pts</span> <span class="o">=</span> <span class="n">pts</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polys</span> <span class="o">=</span> <span class="n">polys</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_cache</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_rlfac_solvers</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nLC_solvers</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span></div>


    <span class="nd">@property</span>
    <span class="nd">@_memo</span>
    <span class="k">def</span> <span class="nf">ppts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;3D matrix of points in each face: n faces x 3 points per face x 3 coords per point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">]</span>
    
    <span class="nd">@property</span>
    <span class="nd">@_memo</span>
    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sparse matrix of vertex-face associations.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">npt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pts</span><span class="p">)</span>
        <span class="n">npoly</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="mi">3</span><span class="o">*</span><span class="n">npoly</span><span class="p">,)),</span> <span class="c1"># data</span>
                                  <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="c1"># row</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">npoly</span><span class="p">),(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())),</span> <span class="c1"># col</span>
                                 <span class="p">(</span><span class="n">npt</span><span class="p">,</span> <span class="n">npoly</span><span class="p">))</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span> <span class="c1"># size</span>
    <span class="nd">@property</span>
    <span class="nd">@_memo</span>
    <span class="k">def</span> <span class="nf">adj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sparse vertex adjacency matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">npt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pts</span><span class="p">)</span>
        <span class="n">npoly</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">)</span>
        <span class="n">adj1</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">npoly</span><span class="p">,)),</span>
                                  <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])),</span> <span class="p">(</span><span class="n">npt</span><span class="p">,</span><span class="n">npt</span><span class="p">))</span>
        <span class="n">adj2</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">npoly</span><span class="p">,)),</span>
                                  <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])),</span> <span class="p">(</span><span class="n">npt</span><span class="p">,</span><span class="n">npt</span><span class="p">))</span>
        <span class="n">adj3</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">npoly</span><span class="p">,)),</span>
                                  <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])),</span> <span class="p">(</span><span class="n">npt</span><span class="p">,</span><span class="n">npt</span><span class="p">))</span>
        <span class="n">alladj</span> <span class="o">=</span> <span class="p">(</span><span class="n">adj1</span> <span class="o">+</span> <span class="n">adj2</span> <span class="o">+</span> <span class="n">adj3</span><span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">alladj</span> <span class="o">+</span> <span class="n">alladj</span><span class="o">.</span><span class="n">T</span>
    
    <span class="nd">@property</span>
    <span class="nd">@_memo</span>
    <span class="k">def</span> <span class="nf">face_normals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normal vector for each face.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute normal vector direction</span>
        <span class="n">nnfnorms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> 
                            <span class="bp">self</span><span class="o">.</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># Normalize to norm 1</span>
        <span class="n">nfnorms</span> <span class="o">=</span> <span class="n">nnfnorms</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">nnfnorms</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="c1"># Ensure that there are no nans (shouldn&#39;t be a problem with well-formed surfaces)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">nfnorms</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="nd">@_memo</span>
    <span class="k">def</span> <span class="nf">vertex_normals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Normal vector for each vertex (average of normals for neighboring faces).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Average adjacent face normals</span>
        <span class="n">nnvnorms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connected</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">face_normals</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">A</span>
        <span class="c1"># Normalize to norm 1</span>
        <span class="k">return</span> <span class="n">nnvnorms</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">nnvnorms</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="nd">@_memo</span>
    <span class="k">def</span> <span class="nf">face_areas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Area of each face.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute normal vector (length is face area)</span>
        <span class="n">nnfnorms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> 
                            <span class="bp">self</span><span class="o">.</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># Compute vector length</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">nnfnorms</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="nd">@property</span>
    <span class="nd">@_memo</span>
    <span class="k">def</span> <span class="nf">cotangent_weights</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cotangent of angle opposite each vertex in each face.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ppts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppts</span>
        <span class="n">cots1</span> <span class="o">=</span> <span class="p">((</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span>
                 <span class="p">(</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span>
                                                                   <span class="n">ppts</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">cots2</span> <span class="o">=</span> <span class="p">((</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span>
                 <span class="p">(</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span>
                                                                   <span class="n">ppts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">cots3</span> <span class="o">=</span> <span class="p">((</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span> <span class="o">*</span>
                 <span class="p">(</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span>
                                                                   <span class="n">ppts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Then we have to sanitize everything..</span>
        <span class="n">cots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">cots1</span><span class="p">,</span> <span class="n">cots2</span><span class="p">,</span> <span class="n">cots3</span><span class="p">])</span>
        <span class="n">cots</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">cots</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cots</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">cots</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">cots</span>

    <span class="nd">@property</span>
    <span class="nd">@_memo</span>
    <span class="k">def</span> <span class="nf">laplace_operator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Laplace-Beltrami operator for this surface. A sparse adjacency matrix with</span>
<span class="sd">        edge weights determined by the cotangents of the angles opposite each edge.</span>
<span class="sd">        Returns a 4-tuple (B,D,W,V) where D is the &#39;lumped mass matrix&#39;, W is the weighted</span>
<span class="sd">        adjacency matrix, and V is a diagonal matrix that normalizes the adjacencies.</span>
<span class="sd">        The &#39;stiffness matrix&#39;, A, can be computed as V - W.</span>

<span class="sd">        The full LB operator can be computed as D^{-1} (V - W).</span>
<span class="sd">        </span>
<span class="sd">        B is the finite element method (FEM) &#39;mass matrix&#39;, which replaces D in FEM analyses.</span>
<span class="sd">        </span>
<span class="sd">        See &#39;Discrete Laplace-Beltrami operators for shape analysis and segmentation&#39;</span>
<span class="sd">        by Reuter et al., 2009 for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">## Lumped mass matrix</span>
        <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">face_areas</span><span class="p">)</span> <span class="o">/</span> <span class="mf">3.0</span>

        <span class="c1">## Stiffness matrix</span>
        <span class="n">npt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pts</span><span class="p">)</span>
        <span class="n">cots1</span><span class="p">,</span> <span class="n">cots2</span><span class="p">,</span> <span class="n">cots3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cotangent_weights</span>
        <span class="c1"># W is weighted adjacency matrix</span>
        <span class="n">W1</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">cots1</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])),</span> <span class="p">(</span><span class="n">npt</span><span class="p">,</span> <span class="n">npt</span><span class="p">))</span>
        <span class="n">W2</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">cots2</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])),</span> <span class="p">(</span><span class="n">npt</span><span class="p">,</span> <span class="n">npt</span><span class="p">))</span>
        <span class="n">W3</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">cots3</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])),</span> <span class="p">(</span><span class="n">npt</span><span class="p">,</span> <span class="n">npt</span><span class="p">))</span>
        <span class="n">W</span> <span class="o">=</span> <span class="p">(</span><span class="n">W1</span> <span class="o">+</span> <span class="n">W1</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">W2</span> <span class="o">+</span> <span class="n">W2</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">W3</span> <span class="o">+</span> <span class="n">W3</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span> <span class="o">/</span> <span class="mf">2.0</span>
        
        <span class="c1"># V is sum of each col</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">dia_matrix</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">W</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">npt</span><span class="p">,</span><span class="n">npt</span><span class="p">))</span>
        
        <span class="c1"># A is stiffness matrix</span>
        <span class="c1">#A = W - V # negative operator -- more useful in practice</span>

        <span class="c1"># For FEM:</span>
        <span class="n">Be1</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">face_areas</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])),</span> <span class="p">(</span><span class="n">npt</span><span class="p">,</span> <span class="n">npt</span><span class="p">))</span>
        <span class="n">Be2</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">face_areas</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])),</span> <span class="p">(</span><span class="n">npt</span><span class="p">,</span> <span class="n">npt</span><span class="p">))</span>
        <span class="n">Be3</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">face_areas</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])),</span> <span class="p">(</span><span class="n">npt</span><span class="p">,</span> <span class="n">npt</span><span class="p">))</span>
        <span class="n">Bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">face_areas</span><span class="p">)</span> <span class="o">/</span> <span class="mi">6</span>
        <span class="n">dBd</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">dia_matrix</span><span class="p">((</span><span class="n">Bd</span><span class="p">,[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">D</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">D</span><span class="p">)))</span>
        <span class="n">B</span> <span class="o">=</span> <span class="p">(</span><span class="n">Be1</span> <span class="o">+</span> <span class="n">Be1</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">Be2</span> <span class="o">+</span> <span class="n">Be2</span><span class="o">.</span><span class="n">T</span> <span class="o">+</span> <span class="n">Be3</span> <span class="o">+</span> <span class="n">Be3</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">/</span><span class="mi">12</span> <span class="o">+</span> <span class="n">dBd</span>
        <span class="k">return</span> <span class="n">B</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">V</span>

<div class="viewcode-block" id="Surface.mean_curvature">
<a class="viewcode-back" href="../../../generated/Surface/cortex.polyutils.Surface.mean_curvature.html#cortex.polyutils.Surface.mean_curvature">[docs]</a>
    <span class="k">def</span> <span class="nf">mean_curvature</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute mean curvature of this surface using the Laplace-Beltrami operator.</span>
<span class="sd">        Curvature is computed at each vertex. It&#39;s probably pretty noisy, and should</span>
<span class="sd">        be smoothed using smooth().</span>

<span class="sd">        Negative values of mean curvature mean that the surface is folded inward</span>
<span class="sd">        (as in a sulcus), positive values of curvature mean that the surface is</span>
<span class="sd">        folded outward (as on a gyrus).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        curv : 1D ndarray, shape (total_verts,)</span>
<span class="sd">            The mean curvature at each vertex.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">B</span><span class="p">,</span><span class="n">D</span><span class="p">,</span><span class="n">W</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">laplace_operator</span>
        <span class="n">npt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
        <span class="n">Dinv</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">dia_matrix</span><span class="p">((</span><span class="n">D</span><span class="o">**-</span><span class="mi">1</span><span class="p">,[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">npt</span><span class="p">,</span><span class="n">npt</span><span class="p">))</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span> <span class="c1"># construct Dinv</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">Dinv</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">V</span><span class="o">-</span><span class="n">W</span><span class="p">))</span>
        <span class="n">curv</span> <span class="o">=</span> <span class="p">(</span><span class="n">L</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pts</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertex_normals</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">curv</span></div>


<div class="viewcode-block" id="Surface.smooth">
<a class="viewcode-back" href="../../../generated/Surface/cortex.polyutils.Surface.smooth.html#cortex.polyutils.Surface.smooth">[docs]</a>
    <span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scalars</span><span class="p">,</span> <span class="n">factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">iterations</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Smooth vertex-wise function given by `scalars` across the surface using</span>
<span class="sd">        mean curvature flow method (see http://brickisland.net/cs177fa12/?p=302).</span>

<span class="sd">        Amount of smoothing is controlled by `factor`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scalars : 1D ndarray, shape (total_verts,)</span>
<span class="sd">            A scalar-valued function across the cortex, such as the curvature</span>
<span class="sd">            supplied by mean_curvature.</span>
<span class="sd">        factor : float, optional</span>
<span class="sd">            Amount of smoothing to perform, larger values smooth more.</span>
<span class="sd">        iterations : int, optional</span>
<span class="sd">            Number of times to repeat smoothing, larger values smooths more.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        smscalars : 1D ndarray, shape (total_verts,)</span>
<span class="sd">            Smoothed scalar values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">factor</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">scalars</span>
        
        <span class="n">B</span><span class="p">,</span><span class="n">D</span><span class="p">,</span><span class="n">W</span><span class="p">,</span><span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">laplace_operator</span>
        <span class="n">npt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
        <span class="n">lfac</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">dia_matrix</span><span class="p">((</span><span class="n">D</span><span class="p">,[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">npt</span><span class="p">,</span><span class="n">npt</span><span class="p">))</span> <span class="o">-</span> <span class="n">factor</span> <span class="o">*</span> <span class="p">(</span><span class="n">W</span><span class="o">-</span><span class="n">V</span><span class="p">)</span>
        <span class="n">goodrows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lfac</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">lfac_solver</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">dsolve</span><span class="o">.</span><span class="n">factorized</span><span class="p">(</span><span class="n">lfac</span><span class="p">[</span><span class="n">goodrows</span><span class="p">][:,</span><span class="n">goodrows</span><span class="p">])</span>
        <span class="n">to_smooth</span> <span class="o">=</span> <span class="n">scalars</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">iterations</span><span class="p">):</span>
            <span class="n">from_smooth</span> <span class="o">=</span> <span class="n">lfac_solver</span><span class="p">((</span><span class="n">D</span> <span class="o">*</span> <span class="n">to_smooth</span><span class="p">)[</span><span class="n">goodrows</span><span class="p">])</span>
            <span class="n">to_smooth</span><span class="p">[</span><span class="n">goodrows</span><span class="p">]</span> <span class="o">=</span> <span class="n">from_smooth</span>
        <span class="n">smscalars</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">scalars</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">smscalars</span><span class="p">[</span><span class="n">goodrows</span><span class="p">]</span> <span class="o">=</span> <span class="n">from_smooth</span>
        <span class="k">return</span> <span class="n">smscalars</span></div>

        
    <span class="nd">@property</span>
    <span class="nd">@_memo</span>
    <span class="k">def</span> <span class="nf">avg_edge_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Average length of all edges in the surface.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">adj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adj</span>
        <span class="n">tadj</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">triu</span><span class="p">(</span><span class="n">adj</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># only entries above main diagonal, in coo format</span>
        <span class="n">edgelens</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(((</span><span class="bp">self</span><span class="o">.</span><span class="n">pts</span><span class="p">[</span><span class="n">tadj</span><span class="o">.</span><span class="n">row</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">pts</span><span class="p">[</span><span class="n">tadj</span><span class="o">.</span><span class="n">col</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">edgelens</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

<div class="viewcode-block" id="Surface.surface_gradient">
<a class="viewcode-back" href="../../../generated/Surface/cortex.polyutils.Surface.surface_gradient.html#cortex.polyutils.Surface.surface_gradient">[docs]</a>
    <span class="k">def</span> <span class="nf">surface_gradient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scalars</span><span class="p">,</span> <span class="n">at_verts</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gradient of a function with values `scalars` at each vertex on the surface.</span>
<span class="sd">        If `at_verts`, returns values at each vertex. Otherwise, returns values at each</span>
<span class="sd">        face.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scalars : 1D ndarray, shape (total_verts,)</span>
<span class="sd">            A scalar-valued function across the cortex.</span>
<span class="sd">        at_verts : bool, optional</span>
<span class="sd">            If True (default), values will be returned for each vertex. Otherwise,</span>
<span class="sd">            values will be returned for each face.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gradu : 2D ndarray, shape (total_verts,3) or (total_polys,3)</span>
<span class="sd">            Contains the x-, y-, and z-axis gradients of the given `scalars` at either</span>
<span class="sd">            each vertex (if `at_verts` is True) or each face.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pu</span> <span class="o">=</span> <span class="n">scalars</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">]</span>
        <span class="n">fe12</span><span class="p">,</span> <span class="n">fe23</span><span class="p">,</span> <span class="n">fe31</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">T</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_facenorm_cross_edge</span><span class="p">]</span>
        <span class="n">pu1</span><span class="p">,</span> <span class="n">pu2</span><span class="p">,</span> <span class="n">pu3</span> <span class="o">=</span> <span class="n">pu</span><span class="o">.</span><span class="n">T</span>
        <span class="n">fa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">face_areas</span>

        <span class="c1"># numexpr is much faster than doing this using numpy!</span>
        <span class="c1">#gradu = ((fe12.T * pu[:,2] +</span>
        <span class="c1">#          fe23.T * pu[:,0] +</span>
        <span class="c1">#          fe31.T * pu[:,1]) / (2 * self.face_areas)).T</span>
        <span class="n">gradu</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">ne</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s2">&quot;(fe12 * pu3 + fe23 * pu1 + fe31 * pu2) / (2 * fa)&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">at_verts</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connected</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">gradu</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">squeeze</span><span class="p">())</span><span class="o">.</span><span class="n">T</span>
        <span class="k">return</span> <span class="n">gradu</span></div>


<div class="viewcode-block" id="Surface.create_biharmonic_solver">
<a class="viewcode-back" href="../../../generated/Surface/cortex.polyutils.Surface.create_biharmonic_solver.html#cortex.polyutils.Surface.create_biharmonic_solver">[docs]</a>
    <span class="k">def</span> <span class="nf">create_biharmonic_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boundary_verts</span><span class="p">,</span> <span class="n">clip_D</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Set up biharmonic equation with Dirichlet boundary conditions on the cortical</span>
<span class="sd">        mesh and precompute Cholesky factorization for solving it. The vertices listed in</span>
<span class="sd">        `boundary_verts` are considered part of the boundary, and will not be included in</span>
<span class="sd">        the factorization.</span>

<span class="sd">        To facilitate Cholesky decomposition (which requires a symmetric matrix), the</span>
<span class="sd">        squared Laplace-Beltrami operator is separated into left-hand-side (L2) and</span>
<span class="sd">        right-hand-side (Dinv) parts. If we write the L-B operator as the product of</span>
<span class="sd">        the stiffness matrix (V-W) and the inverse mass matrix (Dinv), the biharmonic</span>
<span class="sd">        problem is as follows (with `u` denoting non-boundary vertices)</span>

<span class="sd">        .. math::</span>
<span class="sd">            :nowrap:</span>
<span class="sd">            </span>
<span class="sd">            \begin{eqnarray}</span>
<span class="sd">            L^2_{u} \phi &amp;=&amp; -\rho_{u} \\</span>
<span class="sd">            \left[ D^{-1} (V-W) D^{-1} (V-W) \right]_{u} \phi &amp;=&amp; -\rho_{u} \\</span>
<span class="sd">            \left[ (V-W) D^{-1} (V-W) \right]_{u} \phi &amp;=&amp; -\left[D \rho\right]_{u}</span>
<span class="sd">            \end{eqnarray}</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        boundary_verts : list or ndarray of length V</span>
<span class="sd">            Indices of vertices that will be part of the Dirichlet boundary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lhs : sparse matrix</span>
<span class="sd">            Left side of biharmonic problem, (V-W) D^{-1} (V-W)</span>
<span class="sd">        rhs : sparse matrix, dia</span>
<span class="sd">            Right side of biharmonic problem, D</span>
<span class="sd">        Dinv : sparse matrix, dia</span>
<span class="sd">            Inverse mass matrix, D^{-1}</span>
<span class="sd">        lhsfac : cholesky Factor object</span>
<span class="sd">            Factorized left side, solves biharmonic problem</span>
<span class="sd">        notboundary : ndarray, int</span>
<span class="sd">            Indices of non-boundary vertices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">from</span> <span class="nn">scikits.sparse.cholmod</span> <span class="kn">import</span> <span class="n">cholesky</span>
            <span class="n">factorize</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">cholesky</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">solve_A</span>
        <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
            <span class="n">factorize</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">dsolve</span><span class="o">.</span><span class="n">factorized</span>
            
        <span class="n">B</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">laplace_operator</span>
        <span class="n">npt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>

        <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">D</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Find vertices with non-zero mass</span>
        <span class="c1">#g = np.nonzero((L.sum(0) != 0).A.ravel())[0] # Find vertices with non-zero mass</span>
        <span class="n">notboundary</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">npt</span><span class="p">)[</span><span class="n">g</span><span class="p">],</span> <span class="n">boundary_verts</span><span class="p">)</span> <span class="c1"># find non-boundary verts</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">clip_D</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>

        <span class="n">Dinv</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">dia_matrix</span><span class="p">((</span><span class="n">D</span><span class="o">**-</span><span class="mi">1</span><span class="p">,[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">npt</span><span class="p">,</span><span class="n">npt</span><span class="p">))</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span> <span class="c1"># construct Dinv</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">Dinv</span><span class="o">.</span><span class="n">dot</span><span class="p">((</span><span class="n">V</span><span class="o">-</span><span class="n">W</span><span class="p">))</span> <span class="c1"># construct Laplace-Beltrami operator</span>
        
        <span class="n">lhs</span> <span class="o">=</span> <span class="p">(</span><span class="n">V</span><span class="o">-</span><span class="n">W</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="c1"># construct left side, almost squared L-B operator</span>
        <span class="c1">#lhsfac = cholesky(lhs[notboundary][:,notboundary]) # factorize</span>
        <span class="n">lhsfac</span> <span class="o">=</span> <span class="n">factorize</span><span class="p">(</span><span class="n">lhs</span><span class="p">[</span><span class="n">notboundary</span><span class="p">][:,</span><span class="n">notboundary</span><span class="p">])</span> <span class="c1"># factorize</span>
        
        <span class="k">return</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">Dinv</span><span class="p">,</span> <span class="n">lhsfac</span><span class="p">,</span> <span class="n">notboundary</span></div>


    <span class="k">def</span> <span class="nf">_create_interp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">bhsolver</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Creates interpolator that will interpolate values at the given `verts` using</span>
<span class="sd">        biharmonic interpolation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verts : 1D array-like of ints</span>
<span class="sd">            Indices of vertices that will serve as knot points for interpolation.</span>
<span class="sd">        bhsolver : (lhs, rhs, Dinv, lhsfac, notboundary), optional</span>
<span class="sd">            A 5-tuple representing a biharmonic equation solver. This structure</span>
<span class="sd">            is created by create_biharmonic_solver.</span>
<span class="sd">        </span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        _interp : function</span>
<span class="sd">            Function that will interpolate a given set of values across the surface.</span>
<span class="sd">            The values can be 1D or 2D (number of dimensions by len `verts`). Any</span>
<span class="sd">            number of dimensions can be interpolated simultaneously.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bhsolver</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lhs</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">Dinv</span><span class="p">,</span> <span class="n">lhsfac</span><span class="p">,</span> <span class="n">notb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_biharmonic_solver</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lhs</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">Dinv</span><span class="p">,</span> <span class="n">lhsfac</span><span class="p">,</span> <span class="n">notb</span> <span class="o">=</span> <span class="n">bhsolver</span>
        
        <span class="n">npt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">D</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">_interp</span><span class="p">(</span><span class="n">vals</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Interpolate function with values `vals` at the knot points.&quot;&quot;&quot;</span>
            <span class="n">v2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
            <span class="n">nd</span><span class="p">,</span><span class="n">nv</span> <span class="o">=</span> <span class="n">v2</span><span class="o">.</span><span class="n">shape</span>
            <span class="n">ij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="n">nv</span><span class="o">*</span><span class="n">nd</span><span class="p">))</span>
            <span class="n">ij</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">verts</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nv</span><span class="p">),</span> <span class="n">nd</span><span class="p">)]</span>
            <span class="n">ij</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nd</span><span class="p">),</span> <span class="n">nv</span><span class="p">)</span>
            
            <span class="n">r</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">vals</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">ij</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">npt</span><span class="p">,</span><span class="n">nd</span><span class="p">))</span>
            <span class="n">vr</span> <span class="o">=</span> <span class="n">lhs</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
            
            <span class="c1">#phi = lhsfac.solve_A(-vr.todense()[notb]) # 29.9ms</span>
            <span class="c1">#phi = lhsfac.solve_A(-vr[notb]).todense() # 29.3ms</span>
            <span class="c1">#phi = lhsfac.solve_A(-vr[notb].todense()) # 28.2ms</span>
            <span class="n">phi</span> <span class="o">=</span> <span class="n">lhsfac</span><span class="p">(</span><span class="o">-</span><span class="n">vr</span><span class="p">[</span><span class="n">notb</span><span class="p">]</span><span class="o">.</span><span class="n">todense</span><span class="p">())</span>
            
            <span class="n">tphi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npt</span><span class="p">,</span><span class="n">nd</span><span class="p">))</span>
            <span class="n">tphi</span><span class="p">[</span><span class="n">notb</span><span class="p">]</span> <span class="o">=</span> <span class="n">phi</span>
            <span class="n">tphi</span><span class="p">[</span><span class="n">verts</span><span class="p">]</span> <span class="o">=</span> <span class="n">v2</span><span class="o">.</span><span class="n">T</span>
            
            <span class="k">return</span> <span class="n">tphi</span>

        <span class="k">return</span> <span class="n">_interp</span>

<div class="viewcode-block" id="Surface.interp">
<a class="viewcode-back" href="../../../generated/Surface/cortex.polyutils.Surface.interp.html#cortex.polyutils.Surface.interp">[docs]</a>
    <span class="k">def</span> <span class="nf">interp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">vals</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpolates a function between N knot points `verts` with the values `vals`.</span>
<span class="sd">        `vals` can be a D x N array to interpolate multiple functions with the same</span>
<span class="sd">        knot points.</span>

<span class="sd">        Using this function directly is unnecessarily expensive if you want to interpolate</span>
<span class="sd">        many different values between the same knot points. Instead, you should directly</span>
<span class="sd">        create an interpolator function using _create_interp, and then call that function.</span>
<span class="sd">        In fact, that&#39;s exactly what this function does.</span>

<span class="sd">        See create_biharmonic_solver for math details.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verts : 1D array-like of ints</span>
<span class="sd">            Indices of vertices that will serve as knot points for interpolation.</span>
<span class="sd">        vals : 2D ndarray, shape (dimensions, len(verts))</span>
<span class="sd">            Values at the knot points. Can be multidimensional.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tphi : 2D ndarray, shape (total_verts, dimensions)</span>
<span class="sd">            Interpolated value at every vertex on the surface.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_create_interp</span><span class="p">(</span><span class="n">verts</span><span class="p">)(</span><span class="n">vals</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="nd">@_memo</span>
    <span class="k">def</span> <span class="nf">_facenorm_cross_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ppts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppts</span>
        <span class="n">fnorms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">face_normals</span>
        <span class="n">fe12</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">fnorms</span><span class="p">,</span> <span class="n">ppts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ppts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">fe23</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">fnorms</span><span class="p">,</span> <span class="n">ppts</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">ppts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">fe31</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">fnorms</span><span class="p">,</span> <span class="n">ppts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">ppts</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">fe12</span><span class="p">,</span> <span class="n">fe23</span><span class="p">,</span> <span class="n">fe31</span>

<div class="viewcode-block" id="Surface.approx_geodesic_distance">
<a class="viewcode-back" href="../../../generated/Surface/cortex.polyutils.Surface.approx_geodesic_distance.html#cortex.polyutils.Surface.approx_geodesic_distance">[docs]</a>
    <span class="k">def</span> <span class="nf">approx_geodesic_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Computes approximate geodesic distance (in mm) from each vertex in </span>
<span class="sd">        the surface to any vertex in the collection `verts`. This approximation</span>
<span class="sd">        is computed using Varadhan&#39;s formula for geodesic distance based on the</span>
<span class="sd">        heat kernel. This is very fast (quite a bit faster than `geodesic_distance`)</span>
<span class="sd">        but very inaccurate. Use with care.</span>

<span class="sd">        In short, we let heat diffuse across the surface from sources at `verts`,</span>
<span class="sd">        and then look at the resulting heat levels in every other vertex to </span>
<span class="sd">        approximate how far they are from the sources. In theory, this should</span>
<span class="sd">        be very accurate as the duration of heat diffusion goes to zero. In </span>
<span class="sd">        practice, short duration leads to numerical instability and error.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verts : 1D array-like of ints</span>
<span class="sd">            Set of vertices to compute distance from. This function returns the shortest</span>
<span class="sd">            distance to any of these vertices from every vertex in the surface.</span>
<span class="sd">        m : float, optional</span>
<span class="sd">            Scalar on the duration of heat propagation. Default 0.1.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        1D ndarray, shape (total_verts,)</span>
<span class="sd">            Approximate geodesic distance (in mm) from each vertex in the </span>
<span class="sd">            surface to the closest vertex in `verts`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">npt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pts</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">avg_edge_length</span> <span class="o">**</span> <span class="mi">2</span> <span class="c1"># time of heat evolution</span>

        <span class="k">if</span> <span class="n">m</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rlfac_solvers</span><span class="p">:</span>
            <span class="n">B</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">laplace_operator</span>
            <span class="n">nLC</span> <span class="o">=</span> <span class="n">W</span> <span class="o">-</span> <span class="n">V</span> <span class="c1"># negative laplace matrix</span>
            <span class="n">spD</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">dia_matrix</span><span class="p">((</span><span class="n">D</span><span class="p">,[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">npt</span><span class="p">,</span><span class="n">npt</span><span class="p">))</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span> <span class="c1"># lumped mass matrix</span>
            
            <span class="n">lfac</span> <span class="o">=</span> <span class="n">spD</span> <span class="o">-</span> <span class="n">t</span> <span class="o">*</span> <span class="n">nLC</span> <span class="c1"># backward Euler matrix</span>

            <span class="c1"># Exclude rows with zero weight (these break the sparse LU)</span>
            <span class="n">goodrows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lfac</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_goodrows</span> <span class="o">=</span> <span class="n">goodrows</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rlfac_solvers</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">dsolve</span><span class="o">.</span><span class="n">factorized</span><span class="p">(</span><span class="n">lfac</span><span class="p">[</span><span class="n">goodrows</span><span class="p">][:,</span><span class="n">goodrows</span><span class="p">])</span>

        <span class="c1"># Solve system to get u, the heat values</span>
        <span class="n">u0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npt</span><span class="p">,))</span> <span class="c1"># initial heat values</span>
        <span class="n">u0</span><span class="p">[</span><span class="n">verts</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">goodu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rlfac_solvers</span><span class="p">[</span><span class="n">m</span><span class="p">](</span><span class="n">u0</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_goodrows</span><span class="p">])</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npt</span><span class="p">,))</span>
        <span class="n">u</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_goodrows</span><span class="p">]</span> <span class="o">=</span> <span class="n">goodu</span>

        <span class="k">return</span> <span class="o">-</span><span class="mi">4</span> <span class="o">*</span> <span class="n">t</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">u</span><span class="p">)</span></div>


<div class="viewcode-block" id="Surface.geodesic_distance">
<a class="viewcode-back" href="../../../generated/Surface/cortex.polyutils.Surface.geodesic_distance.html#cortex.polyutils.Surface.geodesic_distance">[docs]</a>
    <span class="k">def</span> <span class="nf">geodesic_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">verts</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">fem</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Minimum mesh geodesic distance (in mm) from each vertex in surface to any</span>
<span class="sd">        vertex in the collection `verts`.</span>

<span class="sd">        Geodesic distance is estimated using heat-based method (see &#39;Geodesics in Heat&#39;,</span>
<span class="sd">        Crane et al, 2012). Diffusion of heat along the mesh is simulated and then</span>
<span class="sd">        used to infer geodesic distance. The duration of the simulation is controlled</span>
<span class="sd">        by the parameter `m`. Larger values of `m` will smooth &amp; regularize the distance</span>
<span class="sd">        computation. Smaller values of `m` will roughen and will usually increase error</span>
<span class="sd">        in the distance computation. The default value of 1.0 is probably pretty good.</span>

<span class="sd">        This function caches some data (sparse LU factorizations of the laplace-beltrami</span>
<span class="sd">        operator and the weighted adjacency matrix), so it will be much faster on</span>
<span class="sd">        subsequent runs.</span>

<span class="sd">        The time taken by this function is independent of the number of vertices in verts.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        verts : 1D array-like of ints</span>
<span class="sd">            Set of vertices to compute distance from. This function returns the shortest</span>
<span class="sd">            distance to any of these vertices from every vertex in the surface.</span>
<span class="sd">        m : float, optional</span>
<span class="sd">            Reverse Euler step length. The optimal value is likely between 0.5 and 1.5.</span>
<span class="sd">            Default is 1.0, which should be fine for most cases.</span>
<span class="sd">        fem : bool, optional</span>
<span class="sd">            Whether to use Finite Element Method lumped mass matrix. Wasn&#39;t used in </span>
<span class="sd">            Crane 2012 paper. Doesn&#39;t seem to help any.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        1D ndarray, shape (total_verts,)</span>
<span class="sd">            Geodesic distance (in mm) from each vertex in the surface to the closest</span>
<span class="sd">            vertex in `verts`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">npt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pts</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rlfac_solvers</span> <span class="ow">or</span> <span class="n">m</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nLC_solvers</span><span class="p">:</span>
            <span class="n">B</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">laplace_operator</span>
            <span class="n">nLC</span> <span class="o">=</span> <span class="n">W</span> <span class="o">-</span> <span class="n">V</span> <span class="c1"># negative laplace matrix</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">fem</span><span class="p">:</span>
                <span class="n">spD</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">dia_matrix</span><span class="p">((</span><span class="n">D</span><span class="p">,[</span><span class="mi">0</span><span class="p">]),</span> <span class="p">(</span><span class="n">npt</span><span class="p">,</span><span class="n">npt</span><span class="p">))</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span> <span class="c1"># lumped mass matrix</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">spD</span> <span class="o">=</span> <span class="n">B</span>
            
            <span class="n">t</span> <span class="o">=</span> <span class="n">m</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">avg_edge_length</span> <span class="o">**</span> <span class="mi">2</span> <span class="c1"># time of heat evolution</span>
            <span class="n">lfac</span> <span class="o">=</span> <span class="n">spD</span> <span class="o">-</span> <span class="n">t</span> <span class="o">*</span> <span class="n">nLC</span> <span class="c1"># backward Euler matrix</span>

            <span class="c1"># Exclude rows with zero weight (these break the sparse LU)</span>
            <span class="n">goodrows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lfac</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_goodrows</span> <span class="o">=</span> <span class="n">goodrows</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_rlfac_solvers</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">dsolve</span><span class="o">.</span><span class="n">factorized</span><span class="p">(</span><span class="n">lfac</span><span class="p">[</span><span class="n">goodrows</span><span class="p">][:,</span><span class="n">goodrows</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nLC_solvers</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">dsolve</span><span class="o">.</span><span class="n">factorized</span><span class="p">(</span><span class="n">nLC</span><span class="p">[</span><span class="n">goodrows</span><span class="p">][:,</span><span class="n">goodrows</span><span class="p">])</span>

        <span class="c1"># I. &quot;Integrate the heat flow ̇u = ∆u for some fixed time t&quot;</span>
        <span class="c1"># ---------------------------------------------------------</span>

        <span class="c1"># Solve system to get u, the heat values</span>
        <span class="n">u0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npt</span><span class="p">,))</span> <span class="c1"># initial heat values</span>
        <span class="n">u0</span><span class="p">[</span><span class="n">verts</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">goodu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_rlfac_solvers</span><span class="p">[</span><span class="n">m</span><span class="p">](</span><span class="n">u0</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_goodrows</span><span class="p">])</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npt</span><span class="p">,))</span>
        <span class="n">u</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_goodrows</span><span class="p">]</span> <span class="o">=</span> <span class="n">goodu</span>

        <span class="c1"># II. &quot;Evaluate the vector field X = − ∇u / |∇u|&quot;</span>
        <span class="c1"># -----------------------------------------------</span>

        <span class="c1"># Compute grad u at each face</span>
        <span class="n">gradu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface_gradient</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">at_verts</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        
        <span class="c1"># Compute X (normalized grad u)</span>
        <span class="c1">#X = np.nan_to_num((-gradu.T / np.sqrt((gradu**2).sum(1))).T)</span>
        <span class="n">graduT</span> <span class="o">=</span> <span class="n">gradu</span><span class="o">.</span><span class="n">T</span>
        <span class="n">gusum</span> <span class="o">=</span> <span class="n">ne</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s2">&quot;sum(gradu ** 2, 1)&quot;</span><span class="p">)</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">ne</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="s2">&quot;-graduT / sqrt(gusum)&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># III. &quot;Solve the Poisson equation ∆φ = ∇·X&quot;</span>
        <span class="c1"># ------------------------------------------</span>

        <span class="c1"># Compute integrated divergence of X at each vertex</span>
        <span class="c1">#x1 = x2 = x3 = np.zeros((X.shape[0],))</span>
        <span class="n">c32</span><span class="p">,</span> <span class="n">c13</span><span class="p">,</span> <span class="n">c21</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_cot_edge</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">c32</span> <span class="o">*</span> <span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">c13</span> <span class="o">*</span> <span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x3</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">c21</span> <span class="o">*</span> <span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="n">conn1</span><span class="p">,</span> <span class="n">conn2</span><span class="p">,</span> <span class="n">conn3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_polyconn</span>
        <span class="n">divx</span> <span class="o">=</span> <span class="n">conn1</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span> <span class="o">+</span> <span class="n">conn2</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span> <span class="o">+</span> <span class="n">conn3</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x3</span><span class="p">)</span>

        <span class="c1"># Compute phi (distance)</span>
        <span class="n">goodphi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nLC_solvers</span><span class="p">[</span><span class="n">m</span><span class="p">](</span><span class="n">divx</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_goodrows</span><span class="p">])</span>
        <span class="n">phi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npt</span><span class="p">,))</span>
        <span class="n">phi</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_goodrows</span><span class="p">]</span> <span class="o">=</span> <span class="n">goodphi</span> <span class="o">-</span> <span class="n">goodphi</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

        <span class="c1"># Ensure that distance is zero for selected verts</span>
        <span class="n">phi</span><span class="p">[</span><span class="n">verts</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">return</span> <span class="n">phi</span></div>


<div class="viewcode-block" id="Surface.geodesic_path">
<a class="viewcode-back" href="../../../generated/Surface/cortex.polyutils.Surface.geodesic_path.html#cortex.polyutils.Surface.geodesic_path">[docs]</a>
    <span class="k">def</span> <span class="nf">geodesic_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">max_len</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">d</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Finds the shortest path between two points `a` and `b`.</span>

<span class="sd">        This shortest path is based on geodesic distances across the surface.</span>
<span class="sd">        The path starts at point `a` and selects the neighbor of `a` in the </span>
<span class="sd">        graph that is closest to `b`. This is done iteratively with the last</span>
<span class="sd">        vertex in the path until the last point in the path is `b`.</span>

<span class="sd">        Other Parameters in kwargs are passed to the geodesic_distance </span>
<span class="sd">        function to alter how geodesic distances are actually measured</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a : int</span>
<span class="sd">            Vertex that is the start of the path</span>
<span class="sd">        b : int</span>
<span class="sd">            Vertex that is the end of the path</span>
<span class="sd">        d : array</span>
<span class="sd">            array of geodesic distances, will be computed if not provided</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        max_len : int, optional, default=1000</span>
<span class="sd">            Maximum path length before the function quits. Sometimes it can get stuck</span>
<span class="sd">            in loops, causing infinite paths.</span>
<span class="sd">        m : float, optional</span>
<span class="sd">            Reverse Euler step length. The optimal value is likely between 0.5 and 1.5.</span>
<span class="sd">            Default is 1.0, which should be fine for most cases.</span>
<span class="sd">        fem : bool, optional</span>
<span class="sd">            Whether to use Finite Element Method lumped mass matrix. Wasn&#39;t used in </span>
<span class="sd">            Crane 2012 paper. Doesn&#39;t seem to help any.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        path : list</span>
<span class="sd">            List of the vertices in the path from a to b</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodesic_distance</span><span class="p">([</span><span class="n">b</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])])</span>
            <span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">argmin</span><span class="p">()])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_len</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">path</span>
        <span class="k">return</span> <span class="n">path</span></div>


    <span class="nd">@property</span>
    <span class="nd">@_memo</span>
    <span class="k">def</span> <span class="nf">_cot_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ppts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppts</span>
        <span class="n">cots1</span><span class="p">,</span> <span class="n">cots2</span><span class="p">,</span> <span class="n">cots3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cotangent_weights</span>
        <span class="n">c3</span> <span class="o">=</span> <span class="n">cots3</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ppts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">cots2</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">ppts</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="n">cots1</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">ppts</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">ppts</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">c32</span> <span class="o">=</span> <span class="n">c3</span> <span class="o">-</span> <span class="n">c2</span>
        <span class="n">c13</span> <span class="o">=</span> <span class="n">c1</span> <span class="o">-</span> <span class="n">c3</span>
        <span class="n">c21</span> <span class="o">=</span> <span class="n">c2</span> <span class="o">-</span> <span class="n">c1</span>
        <span class="k">return</span> <span class="n">c32</span><span class="p">,</span> <span class="n">c13</span><span class="p">,</span> <span class="n">c21</span>

    <span class="nd">@property</span>
    <span class="nd">@_memo</span>
    <span class="k">def</span> <span class="nf">_polyconn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">npt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pts</span><span class="p">)</span>
        <span class="n">npoly</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">)</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">npoly</span><span class="p">,))</span>
        <span class="n">c1</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">o</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="nb">range</span><span class="p">(</span><span class="n">npoly</span><span class="p">))),</span> <span class="p">(</span><span class="n">npt</span><span class="p">,</span> <span class="n">npoly</span><span class="p">))</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">o</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="nb">range</span><span class="p">(</span><span class="n">npoly</span><span class="p">))),</span> <span class="p">(</span><span class="n">npt</span><span class="p">,</span> <span class="n">npoly</span><span class="p">))</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        <span class="n">c3</span> <span class="o">=</span> <span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">o</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="nb">range</span><span class="p">(</span><span class="n">npoly</span><span class="p">))),</span> <span class="p">(</span><span class="n">npt</span><span class="p">,</span> <span class="n">npoly</span><span class="p">))</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">,</span> <span class="n">c3</span>

    <span class="nd">@property</span>
    <span class="nd">@_memo</span>
    <span class="k">def</span> <span class="nf">boundary_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return mask of boundary vertices</span>

<span class="sd">        algorithm: for simple mesh, every edge appears in either 1 or 2 polys</span>
<span class="sd">            1 -&gt; border edge</span>
<span class="sd">            2 -&gt; non-border edge</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">first</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">second</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">polygon_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">])</span>
        <span class="n">polygon_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">polygon_edges</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">polygon_edges</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)])</span>

        <span class="n">sort_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">(</span><span class="n">polygon_edges</span><span class="p">)</span>
        <span class="n">sorted_edges</span> <span class="o">=</span> <span class="n">polygon_edges</span><span class="p">[:,</span> <span class="n">sort_order</span><span class="p">]</span>
        <span class="n">duplicate_mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">sorted_edges</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">sorted_edges</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span>

        <span class="n">nonduplicate_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">sorted_edges</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">nonduplicate_mask</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">duplicate_mask</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">nonduplicate_mask</span><span class="p">[</span><span class="mi">1</span><span class="p">:][</span><span class="n">duplicate_mask</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">border_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">border_mask</span><span class="p">[</span><span class="n">sorted_edges</span><span class="p">[:,</span> <span class="n">nonduplicate_mask</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">border_mask</span><span class="p">[</span><span class="n">sorted_edges</span><span class="p">[:,</span> <span class="n">nonduplicate_mask</span><span class="p">][</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">border_mask</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">iter_surfedges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span>
            <span class="k">yield</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span>
            <span class="k">yield</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">iter_surfedges_weighted</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;iterate through edges</span>

<span class="sd">        - same iteration order as self.edge_lengths</span>
<span class="sd">            - border edges will be iterated once, non-border edges will be iterated twice</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edge_lengths</span>
        <span class="n">n_edges</span> <span class="o">=</span> <span class="n">distances</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="mi">3</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">distances</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">yield</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">distances</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">n_edges</span><span class="p">]</span>
            <span class="k">yield</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">distances</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">n_edges</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="nd">@_memo</span>
    <span class="k">def</span> <span class="nf">graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;NetworkX undirected graph representing this Surface.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="n">graph</span><span class="o">.</span><span class="n">add_edges_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_surfedges</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">graph</span>

<div class="viewcode-block" id="Surface.get_graph">
<a class="viewcode-back" href="../../../generated/Surface/cortex.polyutils.Surface.get_graph.html#cortex.polyutils.Surface.get_graph">[docs]</a>
    <span class="k">def</span> <span class="nf">get_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span></div>


    <span class="nd">@property</span>
    <span class="nd">@_memo</span>
    <span class="k">def</span> <span class="nf">edge_lengths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;return vector of edge lengths</span>

<span class="sd">        - same iteration order as iter_surfedges_listed()</span>
<span class="sd">            - border edges will be iterated once, non-border edges will be iterated twice</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_edges</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="n">edges</span><span class="p">[:</span><span class="n">n_edges</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">edges</span><span class="p">[</span><span class="n">n_edges</span><span class="p">:(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n_edges</span><span class="p">),</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppts</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppts</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">edges</span><span class="p">[(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n_edges</span><span class="p">):,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppts</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">ppts</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">edges</span> <span class="o">**=</span> <span class="mi">2</span>
        <span class="n">distances</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">distances</span> <span class="o">**=</span> <span class="mf">0.5</span>

        <span class="k">return</span> <span class="n">distances</span>

    <span class="nd">@property</span>
    <span class="nd">@_memo</span>
    <span class="k">def</span> <span class="nf">weighted_distance_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
        <span class="n">weighted_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="n">weighted_graph</span><span class="o">.</span><span class="n">add_weighted_edges_from</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">iter_surfedges_weighted</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weighted_graph</span>

<div class="viewcode-block" id="Surface.extract_chunk">
<a class="viewcode-back" href="../../../generated/Surface/cortex.polyutils.Surface.extract_chunk.html#cortex.polyutils.Surface.extract_chunk">[docs]</a>
    <span class="k">def</span> <span class="nf">extract_chunk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nfaces</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">auxpts</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Extract a chunk of the surface using breadth first search, for testing purposes&#39;&#39;&#39;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">seed</span>
        <span class="k">if</span> <span class="n">seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pts</span><span class="p">))</span>

        <span class="n">ptmap</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span>
        <span class="n">faces</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">node</span><span class="p">])</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">faces</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nfaces</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">queue</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="o">.</span><span class="n">indices</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">face</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">faces</span><span class="p">:</span>
                    <span class="n">faces</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">face</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[</span><span class="n">face</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">pt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
                            <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>

        <span class="n">pts</span><span class="p">,</span> <span class="n">aux</span><span class="p">,</span> <span class="n">polys</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[],</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">faces</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[</span><span class="n">face</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">pt</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ptmap</span><span class="p">:</span>
                    <span class="n">ptmap</span><span class="p">[</span><span class="n">pt</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">pts</span><span class="p">)</span>
                    <span class="n">pts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pts</span><span class="p">[</span><span class="n">pt</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">auxpts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">aux</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">auxpts</span><span class="p">[</span><span class="n">pt</span><span class="p">])</span>
            <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ptmap</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[</span><span class="n">face</span><span class="p">]])</span>

        <span class="k">if</span> <span class="n">auxpts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">aux</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">pts</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span></div>


<div class="viewcode-block" id="Surface.extract_geodesic_chunk">
<a class="viewcode-back" href="../../../generated/Surface/cortex.polyutils.Surface.extract_geodesic_chunk.html#cortex.polyutils.Surface.extract_geodesic_chunk">[docs]</a>
    <span class="k">def</span> <span class="nf">extract_geodesic_chunk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract a chunk of the surface that is within radius of the origin by</span>
<span class="sd">        geodesic distance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geodesic_distance</span><span class="p">([</span><span class="n">origin</span><span class="p">])</span>
        <span class="n">sel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">dist</span> <span class="o">&lt;</span> <span class="n">radius</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sel_pts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pts</span><span class="p">[</span><span class="n">sel</span><span class="p">]</span>

        <span class="c1"># create new polys with remapped indices</span>

        <span class="c1"># find polys where all 3 verts are in the selected set</span>
        <span class="n">sel_polys_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connected</span><span class="p">[</span><span class="n">sel</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">sel_polys_old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[</span><span class="n">sel_polys_inds</span><span class="p">]</span>

        <span class="c1"># create array to remap indices in polys to new indices</span>
        <span class="n">keyarr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pts</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">keyarr</span><span class="p">[</span><span class="n">sel</span><span class="p">]</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sel</span><span class="p">))</span>

        <span class="n">sel_polys</span> <span class="o">=</span> <span class="n">keyarr</span><span class="p">[</span><span class="n">sel_polys_old</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">sel_pts</span><span class="p">,</span> <span class="n">sel_polys</span></div>



<div class="viewcode-block" id="Surface.polyhedra">
<a class="viewcode-back" href="../../../generated/Surface/cortex.polyutils.Surface.polyhedra.html#cortex.polyutils.Surface.polyhedra">[docs]</a>
    <span class="k">def</span> <span class="nf">polyhedra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wm</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&#39;&#39;&#39;Iterates through the polyhedra that make up the closest volume to a certain vertex&#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">facerow</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connected</span><span class="p">):</span>
            <span class="n">faces</span> <span class="o">=</span> <span class="n">facerow</span><span class="o">.</span><span class="n">indices</span>
            <span class="n">pts</span><span class="p">,</span> <span class="n">polys</span> <span class="o">=</span> <span class="n">_ptset</span><span class="p">(),</span> <span class="n">_quadset</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">faces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">poly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[</span><span class="n">faces</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[</span><span class="n">faces</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">==</span> <span class="n">p</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">assert</span> <span class="n">pts</span><span class="p">[</span><span class="n">wm</span><span class="p">[</span><span class="n">p</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="k">assert</span> <span class="n">pts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pts</span><span class="p">[</span><span class="n">p</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="n">pts</span><span class="p">[</span><span class="n">wm</span><span class="p">[</span><span class="n">poly</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
                <span class="n">pts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pts</span><span class="p">[</span><span class="n">poly</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>

                <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">faces</span><span class="p">:</span>
                    <span class="n">poly</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[</span><span class="n">face</span><span class="p">],</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[</span><span class="n">face</span><span class="p">]</span> <span class="o">==</span> <span class="n">p</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">a</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">wm</span><span class="p">[</span><span class="n">poly</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pts</span><span class="p">[</span><span class="n">poly</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
                    <span class="n">c</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">wm</span><span class="p">[</span><span class="n">poly</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pts</span><span class="p">[</span><span class="n">poly</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">wm</span><span class="p">[</span><span class="n">poly</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>
                    <span class="n">f</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pts</span><span class="p">[</span><span class="n">poly</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span>

                    <span class="n">polys</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
                    <span class="n">polys</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
                    <span class="n">polys</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                    <span class="n">polys</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">))</span>
                    <span class="n">polys</span><span class="p">((</span><span class="n">f</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
                    <span class="n">polys</span><span class="p">((</span><span class="n">d</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">))</span>

            <span class="k">yield</span> <span class="n">pts</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">polys</span><span class="o">.</span><span class="n">triangles</span><span class="p">))</span></div>


<div class="viewcode-block" id="Surface.patches">
<a class="viewcode-back" href="../../../generated/Surface/cortex.polyutils.Surface.patches.html#cortex.polyutils.Surface.patches">[docs]</a>
    <span class="k">def</span> <span class="nf">patches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">auxpts</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">align_polys</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">polys</span><span class="p">):</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">polys</span> <span class="o">==</span> <span class="n">p</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="n">y</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
            <span class="k">return</span> <span class="n">polys</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">half_edge_align</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">polys</span><span class="p">):</span>
            <span class="n">poly</span> <span class="o">=</span> <span class="n">align_polys</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">polys</span><span class="p">)</span>
            <span class="n">mid</span>   <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">poly</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">left</span>  <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">poly</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]]]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">poly</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">mid</span><span class="p">,</span> <span class="n">left</span><span class="p">))</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">pts</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">mid</span><span class="p">,</span> <span class="n">right</span><span class="p">))</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">half_edge</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">pts</span><span class="p">,</span> <span class="n">polys</span><span class="p">):</span>
            <span class="n">poly</span> <span class="o">=</span> <span class="n">align_polys</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">polys</span><span class="p">)</span>
            <span class="n">mid</span>   <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">poly</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">left</span>  <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">poly</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]]]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">pts</span><span class="p">[</span><span class="n">poly</span><span class="p">[:,[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]]</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">stack</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">mid</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">pts</span><span class="p">[</span><span class="n">p</span><span class="p">]])</span>
            <span class="k">return</span> <span class="n">stack</span><span class="p">[(</span><span class="n">distance</span><span class="o">.</span><span class="n">cdist</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">facerow</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connected</span><span class="p">):</span>
            <span class="n">faces</span> <span class="o">=</span> <span class="n">facerow</span><span class="o">.</span><span class="n">indices</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">faces</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">auxpts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">pidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[</span><span class="n">faces</span><span class="p">])</span>
                        <span class="k">yield</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">pts</span><span class="p">[</span><span class="n">pidx</span><span class="p">],</span> <span class="n">auxpts</span><span class="p">[</span><span class="n">pidx</span><span class="p">]])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">pts</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[</span><span class="n">faces</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mf">0.5</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">auxpts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">pts</span> <span class="o">=</span> <span class="n">half_edge</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[</span><span class="n">faces</span><span class="p">])</span>
                        <span class="n">aux</span> <span class="o">=</span> <span class="n">half_edge</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">auxpts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[</span><span class="n">faces</span><span class="p">])</span>
                        <span class="k">yield</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">pts</span><span class="p">,</span> <span class="n">aux</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">yield</span> <span class="n">half_edge_align</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pts</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[</span><span class="n">faces</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="Surface.edge_collapse">
<a class="viewcode-back" href="../../../generated/Surface/cortex.polyutils.Surface.edge_collapse.html#cortex.polyutils.Surface.edge_collapse">[docs]</a>
    <span class="k">def</span> <span class="nf">edge_collapse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>
        <span class="n">face1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span>
        <span class="n">face2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span></div>
</div>



<span class="k">class</span> <span class="nc">_ptset</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">idx</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">idx</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

<span class="k">class</span> <span class="nc">_quadset</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polys</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quad</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">quad</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">quad</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">triangles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">quad</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polys</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
            <span class="k">yield</span> <span class="n">quad</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">yield</span> <span class="p">[</span><span class="n">quad</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">quad</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">quad</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>
</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">pycortex</a></h1>






<p>
<iframe src="https://ghbtns.com/github-btn.html?user=gallantlab&repo=pycortex&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../segmentation_guide.html">Surface Segmentation and Flattening</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../database.html">Surface Database</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../align.html">Alignments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../rois.html">Surface-defined ROIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../transforms.html">Transform formats</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../colormaps.html">Colormaps</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../auto_examples/index.html">Example Gallery</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api_reference_flat.html">Python API Reference</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2012, James Gao.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.4.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>